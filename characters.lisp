(in-package :opengl-text)

(defun create-char-path (char font em)
  (let ((bb-glyph (zpb-ttf:bounding-box (zpb-ttf:find-glyph char font)))
	(em (1- em)))
    (let ((scale-x (- (zpb-ttf:xmax bb-glyph) (zpb-ttf:xmin bb-glyph)))
	  (scale-y (- (zpb-ttf:ymax bb-glyph) (zpb-ttf:ymin bb-glyph))))
      ;; whitespace has no extent
      (when (zerop scale-x) (setf scale-x 1))
      (when (zerop scale-y) (setf scale-y 1))
      (paths-ttf:paths-from-glyph (zpb-ttf:find-glyph char font)
				  :scale-x (/ em scale-x)
				  :scale-y (- (/ em scale-y))))))

(defun draw-char (char gl-text)
  (let ((em (emsquare-of gl-text)))
   (let ((char-path (create-char-path char (font-loader-of gl-text) em))
	 (aa-state (aa:make-state))
	 (out-array (make-array (list em em 4) :initial-element 0)))
     (destructuring-bind (r g b) (color-of gl-text)
       (flet ((draw-function (x y alpha)
		(if (array-in-bounds-p out-array (- h y) x 0)
		    (setf (aref out-array (- h y) x 0) r
			  (aref out-array (- h y) x 1) g
			  (aref out-array (- h y) x 2) b
			  (aref out-array (- h y) x 3) (clamp alpha 0 255))
		    (warn "Out of bounds: ~a ~a" (- h y) x))))
	 (aa:cells-sweep (vectors:update-state aa-state char-path) #'draw-function)
	 out-array)))))

(defun compute-actual-slice (char gl-text)
  (let ((font (font-loader-of gl-text)))
    (let ((glyph (zpb-ttf:find-glyph char font))
	  (bb (zpb-ttf:bounding-box font)))
      (let ((base (max (- (zpb-ttf:xmax bb)
			  (zpb-ttf:xmin bb))
		       (- (zpb-ttf:ymax bb)
			  (zpb-ttf:ymin bb))))
	    (x-edge (zpb-ttf:xmin bb))
	    (y-edge (zpb-ttf:ymin bb))
	    (bb-glyph (zpb-ttf:bounding-box glyph)))
	(mapcar #'float
		(list (/ (- (zpb-ttf:xmin bb-glyph) x-edge) base)
		      (/ (- (zpb-ttf:ymin bb-glyph) y-edge) base)
		      (/ (- (zpb-ttf:xmax bb-glyph) x-edge) base)
		      (+ (/ (- (zpb-ttf:ymax bb-glyph) y-edge) base)
			 (/ 4 (emsquare-of gl-text)))))))))

(defun old-chars-reinsert-add-new (charh new-char new-count new-count-ext)
  (let ((old-chars (sort (hash-table-alist charh)
			 #'< :key #'(lambda (k)
				      (aref (cdr k) 0 0))))
	(new-charh (make-hash-table)))
    (iter (for (old-char . nil) in old-chars)
	  (for i from 0)
	  (setf (gethash old-char new-charh)
		(make-array '(4 2)
			    :initial-contents
			    (list (list (float (/ i new-count-ext)) 0.0)
				  (list (float (/ (1+ i) new-count-ext)) 0.0)
				  (list (float (/ (1+ i) new-count-ext)) 1.0)
				  (list (float (/ i new-count-ext)) 1.0)))))
    (setf (gethash new-char new-charh)
	  (make-array '(4 2)
		      :initial-contents
		      (list (list (float (/ (1- new-count) new-count-ext)) 0.0)
			    (list (float (/ new-count new-count-ext)) 0.0)
			    (list (float (/ new-count new-count-ext)) 1.0)
			    (list (float (/ (1- new-count) new-count-ext)) 1.0))))
    new-charh))

(defgeneric add-char (char gl-text)
  (:method ((char character) (gl-text opengl-text))
    (let ((charh (character-hash-of gl-text))
	  (em (emsquare-of gl-text)))
      (let ((new-count (1+ (hash-table-count charh))))
	(let* ((new-texture (if (or (null (texture-of gl-text))
				    (> new-count (character-cells em (texture-of gl-text))))
				(make-new-texture-array em new-count)
				(texture-of gl-text)))
	       (new-count-ext (character-cells em new-texture)))
	  (when (and (texture-of gl-text)
		     (not (eq (texture-of gl-text) new-texture)))
	    (map-subarray (texture-of gl-text) new-texture
			  :target-range `((0 ,(1- (array-dimension (texture-of gl-text) 0)))
					  (0 ,(1- (array-dimension (texture-of gl-text) 1)))
					  :all)))
	  (draw-char-on char new-texture (* em (hash-table-count charh)) gl-text)
	  (setf (character-hash-of gl-text)
		(old-chars-reinsert-add-new charh char new-count new-count-ext))
	  (setf (texture-of gl-text) new-texture)
	  (send-texture new-texture gl-text)
	  (gethash char (character-hash-of gl-text)))))))

(defgeneric ensure-characters (characters gl-text)
  (:method ((characters sequence) (gl-text opengl-text))
    (let ((chars-loaded (hash-table-keys (character-hash-of gl-text)))
	  (texture (texture-of gl-text))
	  (em (emsquare-of gl-text)))
      (let ((more-chars (set-difference (coerce characters 'list) chars-loaded)))
	(when more-chars
	  (let ((chars (append chars-loaded more-chars)))
	    (setf (texture-of gl-text) (make-new-texture-array em (length chars)))
	    (when chars-loaded
	      (iter (for cell from 0 below chars-loaded)
		    (copy-character texture cell (texture-of gl-text) cell em)))
	    (map nil (rcurry #'get-char-texture-coords gl-text) more-chars)))))))
