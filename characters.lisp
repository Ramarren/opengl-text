(in-package :opengl-text)

(defun create-char-path (char shift gl-text)
  (let ((bb (zpb-ttf:bounding-box (font-loader-of gl-text)))
	(bb-glyph (zpb-ttf:bounding-box (zpb-ttf:find-glyph char (font-loader-of gl-text))))
	(em (1- (emsquare-of gl-text)))
	(font (font-loader-of gl-text)))
    (let ((scaler (max (- (zpb-ttf:xmax bb)
			  (zpb-ttf:xmin bb))
		       (- (zpb-ttf:ymax bb)
			  (zpb-ttf:ymin bb))))
	  (scale-x (- (zpb-ttf:xmax bb-glyph) (zpb-ttf:xmin bb-glyph)))
	  (scale-y (- (zpb-ttf:ymax bb-glyph) (zpb-ttf:ymin bb-glyph))))
      ;; whitespace has no extent
      (when (zerop scale-x) (setf scale-x 1))
      (when (zerop scale-y) (setf scale-y 1))
      (setf (scaler-of gl-text) scaler)
      (setf (scale-to-unit-of gl-text) (/ scaler (zpb-ttf:units/em font)))
      (paths-ttf:paths-from-glyph (zpb-ttf:find-glyph char font)
				  :offset (paths:make-point (+ shift
							       (* em
								  (- (/ (zpb-ttf:xmin bb-glyph) scale-x))))
							    (+ (1+ em)
							       (* em
								  (/ (zpb-ttf:ymin bb-glyph) scale-y))))
				  :scale-x (/ em scale-x)
				  :scale-y (- (/ em scale-y))))))

(defun draw-char-on (char tex-array shift gl-text)
  (let ((char-path (create-char-path char shift gl-text))
	(aa-state (aa:make-state))
	(h (array-dimension tex-array 0)))
    (destructuring-bind (r g b) (color-of gl-text)
      (flet ((draw-function (x y alpha)
	       (if (array-in-bounds-p tex-array (- h y) x 0)
		   (setf (aref tex-array (- h y) x 0) r
			 (aref tex-array (- h y) x 1) g
			 (aref tex-array (- h y) x 2) b
			 (aref tex-array (- h y) x 3) (clamp alpha 0 255))
		   (warn "Out of bounds: ~a ~a" (- h y) x))))
	(aa:cells-sweep (vectors:update-state aa-state char-path) #'draw-function)))))

(defun compute-actual-slice (char gl-text)
  (let ((font (font-loader-of gl-text)))
    (let ((glyph (zpb-ttf:find-glyph char font))
	  (bb (zpb-ttf:bounding-box font)))
      (let ((base (max (- (zpb-ttf:xmax bb)
			  (zpb-ttf:xmin bb))
		       (- (zpb-ttf:ymax bb)
			  (zpb-ttf:ymin bb))))
	    (x-edge (zpb-ttf:xmin bb))
	    (y-edge (zpb-ttf:ymin bb))
	    (bb-glyph (zpb-ttf:bounding-box glyph)))
	(mapcar #'float
		(list (/ (- (zpb-ttf:xmin bb-glyph) x-edge) base)
		      (/ (- (zpb-ttf:ymin bb-glyph) y-edge) base)
		      (/ (- (zpb-ttf:xmax bb-glyph) x-edge) base)
		      (+ (/ (- (zpb-ttf:ymax bb-glyph) y-edge) base)
			 (/ 4 (emsquare-of gl-text)))))))))

(defun old-chars-reinsert-add-new (charh new-char new-count new-count-ext)
  (let ((old-chars (sort (hash-table-alist charh)
			 #'< :key #'(lambda (k)
				      (aref (cdr k) 0 0))))
	(new-charh (make-hash-table)))
    (iter (for (old-char . nil) in old-chars)
	  (for i from 0)
	  (setf (gethash old-char new-charh)
		(make-array '(4 2)
			    :initial-contents
			    (list (list (float (/ i new-count-ext)) 0.0)
				  (list (float (/ (1+ i) new-count-ext)) 0.0)
				  (list (float (/ (1+ i) new-count-ext)) 1.0)
				  (list (float (/ i new-count-ext)) 1.0)))))
    (setf (gethash new-char new-charh)
	  (make-array '(4 2)
		      :initial-contents
		      (list (list (float (/ (1- new-count) new-count-ext)) 0.0)
			    (list (float (/ new-count new-count-ext)) 0.0)
			    (list (float (/ new-count new-count-ext)) 1.0)
			    (list (float (/ (1- new-count) new-count-ext)) 1.0))))
    new-charh))

(defgeneric add-char (char gl-text)
  (:method ((char character) (gl-text opengl-text))
    (let ((charh (character-hash-of gl-text))
	  (em (emsquare-of gl-text)))
      (let ((new-count (1+ (hash-table-count charh))))
	(let* ((new-texture (if (or (null (texture-of gl-text))
				    (> new-count (character-cells em (texture-of gl-text))))
				(make-new-texture-array em new-count)
				(texture-of gl-text)))
	       (new-count-ext (character-cells em new-texture)))
	  (when (and (texture-of gl-text)
		     (not (eq (texture-of gl-text) new-texture)))
	    (map-subarray (texture-of gl-text) new-texture
			  :target-range `((0 ,(1- (array-dimension (texture-of gl-text) 0)))
					  (0 ,(1- (array-dimension (texture-of gl-text) 1)))
					  :all)))
	  (draw-char-on char new-texture (* em (hash-table-count charh)) gl-text)
	  (setf (character-hash-of gl-text)
		(old-chars-reinsert-add-new charh char new-count new-count-ext))
	  (setf (texture-of gl-text) new-texture)
	  (send-texture new-texture gl-text)
	  (gethash char (character-hash-of gl-text)))))))

(defgeneric ensure-characters (characters gl-text)
  (:method ((characters sequence) (gl-text opengl-text))
    (let ((chars-loaded (hash-table-keys (character-hash-of gl-text)))
	  (texture (texture-of gl-text))
	  (em (emsquare-of gl-text)))
      (let ((more-chars (set-difference (coerce characters 'list) chars-loaded)))
	(when more-chars
	  (let ((chars (append chars-loaded more-chars)))
	    (setf (texture-of gl-text) (make-new-texture-array em (length chars)))
	    (when chars-loaded
	      (iter (for cell from 0 below chars-loaded)
		    (copy-character texture cell (texture-of gl-text) cell em)))
	    (map nil (rcurry #'get-char-texture-coords gl-text) more-chars)))))))
